<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Half-Frame Splitter Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" id="opencv-script"></script>
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --text: #1e293b; --card-bg: white; --border: #e2e8f0; }
        body.dark { --bg: #0f172a; --text: #f8fafc; --card-bg: #1e293b; --border: #334155; }
        
        body { font-family: system-ui, sans-serif; background: var(--bg); padding: 2rem; color: var(--text); line-height: 1.5; transition: background 0.3s; }
        .container { max-width: 1100px; margin: 0 auto; }
        .status-bar { background: #e2e8f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-weight: bold; border-left: 5px solid #94a3b8; color: #1e293b; }
        body.dark .status-bar { background: #334155; color: white; }

        .controls { background: var(--card-bg); padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-bottom: 2rem; display: flex; gap: 20px; align-items: flex-end; flex-wrap: wrap; border: 1px solid var(--border); }
        .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; }
        .card { background: var(--card-bg); padding: 15px; border-radius: 8px; border: 2px solid var(--border); transition: border-color 0.2s; }
        .card:hover { border-color: var(--primary); }
        
        .preview-container { position: relative; width: 100%; aspect-ratio: 3/2; background: #000; overflow: hidden; display: flex; align-items: center; justify-content: center; border-radius: 4px; border: 1px solid var(--border); }
        canvas { max-width: 100%; max-height: 100%; image-rendering: auto; }

        .btn { background: var(--primary); color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px; }
        .btn:disabled { background: #94a3b8; cursor: not-allowed; }
        .btn-alt { background: #64748b; }
        .btn-dark { background: #475569; }
        .rotate-btn { background: #475569; color: white; border: none; border-radius: 4px; padding: 2px 8px; font-size: 10px; cursor: pointer; margin-left: 5px; }

        .slider-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-weight: 700; font-size: 10px; text-transform: uppercase; color: var(--text); opacity: 0.8; }
    </style>
</head>
<body class="dark">

<div class="container">
    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h1 style="margin:0;">üéûÔ∏è AI Half-Frame Splitter</h1>
        <button class="btn btn-dark" onclick="document.body.classList.toggle('dark')">üåó Toggle Theme</button>
    </div>
    
    <div id="status" class="status-bar">‚åõ Loading Engine...</div>

    <div class="controls">
        <div class="slider-group">
            <label>1. Upload Folder</label>
            <input type="file" id="fileInput" webkitdirectory directory multiple disabled>
        </div>
        <div class="slider-group">
            <label>2. Global Sensitivity: <span id="sensVal">45</span></label>
            <input type="range" id="sensitivity" min="5" max="250" value="45">
        </div>
        <button class="btn btn-alt" id="globalSyncBtn" disabled>üîÑ Sync All</button>
        <button class="btn" style="background: #ef4444;" onclick="location.reload()">üóëÔ∏è Reset All</button>
        <button class="btn" id="downloadAll" disabled>üì• Download ZIP</button>
    </div>

    <div id="gallery" class="gallery"></div>
</div>

<script>
    let originalImages = []; 
    let activeCardId = null;
    let currentSessionId = 0;
    let currentFolderName = "half_frame_export";

    const status = document.getElementById('status');
    const fileInput = document.getElementById('fileInput');
    const gallery = document.getElementById('gallery');
    const downloadBtn = document.getElementById('downloadAll');
    const globalSyncBtn = document.getElementById('globalSyncBtn');
    const sensInput = document.getElementById('sensitivity');
    const sensVal = document.getElementById('sensVal');

    document.getElementById('opencv-script').onload = () => {
        if (typeof cv !== 'undefined' && cv.runtimeInitialized) { onCvReady(); } 
        else { cv.onRuntimeInitialized = onCvReady; }
    };

    function onCvReady() {
        status.innerText = "‚úÖ Ready.";
        status.style.background = "#065f46"; status.style.color = "white";
        fileInput.disabled = false;
    }

    window.addEventListener('keydown', (e) => {
        if (!activeCardId) return;
        const item = originalImages.find(i => i.id === activeCardId);
        if (!item) return;
        if (e.key === 'ArrowRight') {
            item.threshold = Math.min(250, item.threshold + 1);
            runDetectionOnItem(item);
        } else if (e.key === 'ArrowLeft') {
            item.threshold = Math.max(5, item.threshold - 1);
            runDetectionOnItem(item);
        }
    });

    fileInput.addEventListener('change', async (e) => {
        const thisSessionId = ++currentSessionId;
        const files = Array.from(e.target.files).filter(f => f.type.startsWith('image/') || /\.(jpe?g|png|webp)$/i.test(f.name));
        if (files.length === 0) return;
        
        if (files[0].webkitRelativePath) { currentFolderName = files[0].webkitRelativePath.split('/')[0]; }

        const globalVal = parseInt(sensInput.value);
        let count = 0;

        for (const file of files) {
            if (thisSessionId !== currentSessionId) return;
            count++;
            status.innerText = `‚åõ Analyzing ${count} of ${files.length}...`;

            const img = await loadImage(file);
            const item = {
                id: Math.random().toString(36).substr(2, 9),
                img, name: file.name, threshold: globalVal,
                rotation: 0, centerX: 0, gutterWidth: 0,
                isOverridden: false, isCenterManuallySet: false
            };
            
            originalImages.push(item);
            renderCard(item);
            runDetectionOnItem(item); 
        }
        globalSyncBtn.disabled = downloadBtn.disabled = false;
        status.innerText = `‚úÖ Loaded ${originalImages.length} images from "${currentFolderName}"`;
    });

    globalSyncBtn.onclick = () => {
        const globalVal = parseInt(sensInput.value);
        originalImages.forEach(item => {
            if (!item.isOverridden) {
                item.threshold = globalVal;
                runDetectionOnItem(item);
            }
        });
    };

    sensInput.oninput = (e) => sensVal.innerText = e.target.value;

    function runDetectionOnItem(item) {
        // We detect from the current rendered state of the card's canvas
        const canvas = document.getElementById(`c-${item.id}`);
        if (!canvas) return;
        const res = autoDetectGutterFromCanvas(canvas, item.threshold, item.isCenterManuallySet ? item.centerX : null);
        item.centerX = res.centerX;
        item.gutterWidth = res.gutterWidth;
        item.refreshUI();
    }

    function renderCard(item) {
        let card = document.getElementById(`card-${item.id}`);
        if (!card) {
            card = document.createElement('div');
            card.className = 'card';
            card.id = `card-${item.id}`;
            card.onmouseenter = () => activeCardId = item.id;
            card.onmouseleave = () => activeCardId = null;
            gallery.appendChild(card);
        }

        item.refreshUI = () => {
            const isVertical = item.rotation % 180 !== 0;
            const displayWidth = isVertical ? item.img.height : item.img.width;
            const displayHeight = isVertical ? item.img.width : item.img.height;

            card.innerHTML = `
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:8px;">
                    <div style="width:70%; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;">
                        <strong style="font-size:10px;">${item.name}</strong>
                    </div>
                    <div style="display:flex; align-items:center; gap:5px;">
                        <button class="rotate-btn" id="rot-${item.id}">üîÑ</button>
                        <label style="font-size:9px; color:${item.isOverridden ? '#fbbf24' : 'inherit'}">
                            <input type="checkbox" ${item.isOverridden ? 'checked' : ''} id="lock-${item.id}"> LOCK
                        </label>
                    </div>
                </div>
                <div class="preview-container"><canvas id="c-${item.id}"></canvas></div>
                <div style="margin-top:10px; padding:8px; border-radius:4px; background:rgba(0,0,0,0.1); border: 1px solid var(--border);">
                    <label style="font-size:9px;">Sensitivity: <b>${item.threshold}</b></label>
                    <input type="range" style="width:100%" min="5" max="250" value="${item.threshold}" id="s-${item.id}">
                </div>
            `;

            const canvas = card.querySelector(`#c-${item.id}`);
            canvas.width = displayWidth;
            canvas.height = displayHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.save();
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate((item.rotation * Math.PI) / 180);
            ctx.drawImage(item.img, -item.img.width/2, -item.img.height/2);
            ctx.restore();
            
            ctx.fillStyle = "rgba(255, 0, 0, 0.4)";
            ctx.fillRect(item.centerX - (item.gutterWidth/2), 0, item.gutterWidth, canvas.height);
            ctx.strokeStyle = item.isOverridden ? "#fbbf24" : "#22d3ee";
            ctx.lineWidth = Math.max(15, canvas.width / 120);
            ctx.beginPath(); ctx.moveTo(item.centerX, 0); ctx.lineTo(item.centerX, canvas.height); ctx.stroke();

            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                item.centerX = (e.offsetX) * (canvas.width / rect.width);
                item.isOverridden = item.isCenterManuallySet = true;
                item.refreshUI();
            };
            card.querySelector(`#lock-${item.id}`).onchange = (e) => {
                item.isOverridden = e.target.checked;
                if(!item.isOverridden) item.isCenterManuallySet = false;
                item.refreshUI();
            };
            card.querySelector(`#s-${item.id}`).oninput = (e) => {
                item.threshold = parseInt(e.target.value);
                item.isOverridden = true;
                runDetectionOnItem(item);
            };
            card.querySelector(`#rot-${item.id}`).onclick = () => {
                item.rotation = (item.rotation + 90) % 360;
                item.isCenterManuallySet = false; // Reset center on rotate
                item.isOverridden = true;
                // Timeout ensures the canvas reflows before we scan it
                setTimeout(() => runDetectionOnItem(item), 10); 
            };
        };
        item.refreshUI();
    }

    function autoDetectGutterFromCanvas(canvas, threshVal, lockedX = null) {
        let centerX = lockedX !== null ? lockedX : canvas.width / 2;
        let gutterWidth = 0;
        try {
            let src = cv.imread(canvas);
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            let scanW = src.cols * 0.2;
            let startX = Math.max(0, Math.min((lockedX || src.cols * 0.5) - (scanW/2), src.cols - scanW));
            let roi = gray.roi(new cv.Rect(startX, 0, scanW, src.rows));
            cv.threshold(roi, roi, threshVal, 255, cv.THRESH_BINARY_INV);
            let colSums = [];
            for (let x = 0; x < roi.cols; x++) {
                let sum = 0;
                for (let y = 0; y < roi.rows; y++) { if (roi.ucharAt(y, x) === 255) sum++; }
                colSums.push(sum / roi.rows);
            }
            let sIdx = -1, eIdx = -1, maxR = 0, curS = -1;
            for(let i=0; i < colSums.length; i++) {
                if(colSums[i] > 0.6) { if(curS === -1) curS = i; }
                else { if(curS !== -1) { if((i-curS) > maxR){ sIdx=curS; eIdx=i; maxR=i-curS; } curS=-1; } }
            }
            if (sIdx !== -1) {
                if (lockedX === null) centerX = startX + ((sIdx + eIdx) / 2);
                gutterWidth = (eIdx - sIdx) + 4;
            }
            src.delete(); gray.delete(); roi.delete();
        } catch (e) { console.warn(e); }
        return { centerX, gutterWidth };
    }

    function loadImage(file) {
        return new Promise(res => {
            const r = new FileReader();
            r.onload = e => { const i = new Image(); i.onload = () => res(i); i.src = e.target.result; };
            r.readAsDataURL(file);
        });
    }

    downloadBtn.onclick = async () => {
        const zip = new JSZip();
        status.innerText = "üì¶ Exporting high-res images...";
        for (const item of originalImages) {
            const canvas = document.getElementById(`c-${item.id}`);
            const w = canvas.width;
            const h = canvas.height;
            const leftW = item.centerX - (item.gutterWidth/2);
            const rightStart = item.centerX + (item.gutterWidth/2);
            const rightW = w - rightStart;

            await addCropToZip(zip, canvas, 0, leftW, `${item.name.split('.')[0]}_1.jpg`);
            await addCropToZip(zip, canvas, rightStart, rightW, `${item.name.split('.')[0]}_2.jpg`);
        }
        const content = await zip.generateAsync({type: "blob"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `${currentFolderName}_SPLIT.zip`;
        link.click();
        status.innerText = "‚úÖ Download Complete!";
    };

    function addCropToZip(zip, sourceCanvas, x, w, filename) {
        return new Promise(resolve => {
            const c = document.createElement('canvas');
            c.width = w; c.height = sourceCanvas.height;
            const ctx = c.getContext('2d');
            ctx.drawImage(sourceCanvas, x, 0, w, c.height, 0, 0, w, c.height);
            c.toBlob(b => { zip.file(filename, b); resolve(); }, 'image/jpeg', 0.98);
        });
    }
</script>
</body>
</html>