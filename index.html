<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Half-Frame Splitter Pro</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script async src="https://docs.opencv.org/4.5.4/opencv.js" id="opencv-script"></script>
    <style>
        :root { --primary: #2563eb; --bg: #f8fafc; --text: #1e293b; --card-bg: white; --border: #e2e8f0; }
        body.dark { --bg: #0f172a; --text: #f8fafc; --card-bg: #1e293b; --border: #334155; }
        
        body { font-family: system-ui, sans-serif; background: var(--bg); padding: 2rem; color: var(--text); line-height: 1.5; transition: background 0.3s; }
        .container { max-width: 1100px; margin: 0 auto; }
        .status-bar { background: #e2e8f0; padding: 15px; border-radius: 8px; margin-bottom: 20px; font-weight: bold; border-left: 5px solid #94a3b8; color: #1e293b; }
        body.dark .status-bar { background: #334155; color: white; }

        .controls { background: var(--card-bg); padding: 1.5rem; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); margin-bottom: 2rem; display: flex; gap: 20px; align-items: flex-end; flex-wrap: wrap; border: 1px solid var(--border); }
        .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 1.5rem; }
        .card { background: var(--card-bg); padding: 15px; border-radius: 8px; border: 2px solid var(--border); transition: border-color 0.2s; }
        .card:hover { border-color: var(--primary); }
        
        .preview-container { position: relative; width: 100%; aspect-ratio: 3/2; background: #000; overflow: hidden; display: flex; align-items: center; justify-content: center; border-radius: 4px; border: 1px solid var(--border); }
        canvas { max-width: 100%; max-height: 100%; image-rendering: pixelated; }

        .btn { background: var(--primary); color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600; font-size: 13px; }
        .btn:disabled { background: #94a3b8; cursor: not-allowed; }
        .btn-alt { background: #64748b; }
        .btn-dark { background: #475569; }

        .slider-group { display: flex; flex-direction: column; gap: 8px; }
        label { font-weight: 700; font-size: 10px; text-transform: uppercase; color: var(--text); opacity: 0.8; }
        input[type="range"] { cursor: pointer; }
    </style>
</head>
<body class="dark">

<div class="container">
    <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
        <h1 style="margin:0;">üéûÔ∏è AI Half-Frame Splitter</h1>
        <button class="btn btn-dark" onclick="document.body.classList.toggle('dark')">üåó Toggle Theme</button>
    </div>
    
    <div id="status" class="status-bar">‚åõ Initializing Engine...</div>

    <div class="controls">
        <div class="slider-group">
            <label>1. Upload Folder</label>
            <input type="file" id="fileInput" webkitdirectory directory multiple disabled>
        </div>
        <div class="slider-group">
            <label>2. Global Sensitivity: <span id="sensVal">45</span></label>
            <input type="range" id="sensitivity" min="5" max="250" value="45">
        </div>
        <button class="btn btn-alt" id="globalSyncBtn" disabled>üîÑ Sync All</button>
        <button class="btn" style="background: #ef4444;" id="resetBtn">üóëÔ∏è Reset All</button>
        <button class="btn" id="downloadAll" disabled>üì• Download ZIP</button>
    </div>

    <div id="gallery" class="gallery"></div>
</div>

<script>
    let originalImages = []; 
    let activeCardId = null;
    let currentSessionId = 0;
    let currentFolderName = "half_frame_export";

    const status = document.getElementById('status');
    const fileInput = document.getElementById('fileInput');
    const gallery = document.getElementById('gallery');
    const downloadBtn = document.getElementById('downloadAll');
    const globalSyncBtn = document.getElementById('globalSyncBtn');
    const resetBtn = document.getElementById('resetBtn');
    const sensInput = document.getElementById('sensitivity');
    const sensVal = document.getElementById('sensVal');

    // --- OPENCV LOAD ---
    document.getElementById('opencv-script').onload = () => {
        if (typeof cv !== 'undefined' && cv.runtimeInitialized) { onCvReady(); } 
        else { cv.onRuntimeInitialized = onCvReady; }
    };

    function onCvReady() {
        status.innerText = "‚úÖ Ready. Folder upload enabled (Images only).";
        status.style.background = "#065f46"; status.style.color = "white";
        fileInput.disabled = false;
    }

    // --- RESET ---
    resetBtn.onclick = () => {
        currentSessionId++; 
        originalImages = [];
        gallery.innerHTML = '';
        fileInput.value = '';
        currentFolderName = "half_frame_export";
        globalSyncBtn.disabled = downloadBtn.disabled = true;
        status.innerText = "Cleared. Ready for new folder.";
        status.style.background = "#334155";
    };

    // --- KEYBOARD LISTENER ---
    window.addEventListener('keydown', (e) => {
        if (!activeCardId) return;
        const item = originalImages.find(i => i.id === activeCardId);
        if (!item) return;

        if (e.key === 'ArrowRight') {
            item.threshold = Math.min(250, item.threshold + 1);
            updateLogic(item);
        } else if (e.key === 'ArrowLeft') {
            item.threshold = Math.max(5, item.threshold - 1);
            updateLogic(item);
        }
    });

    function updateLogic(item) {
        item.isOverridden = true;
        const res = autoDetectGutter(item.img, item.threshold, item.isCenterManuallySet ? item.centerX : null);
        item.centerX = res.centerX;
        item.gutterWidth = res.gutterWidth;
        item.refreshUI();
    }

    // --- UPLOAD HANDLER (WITH IMPROVED FILTERING) ---
    fileInput.addEventListener('change', async (e) => {
        const thisSessionId = ++currentSessionId;
        
        // Filter: Must be an image MIME type OR have an image extension
        const files = Array.from(e.target.files).filter(file => {
            const isImgMime = file.type.startsWith('image/');
            const isImgExt = /\.(jpe?g|png|webp|tiff?|bmp)$/i.test(file.name);
            return isImgMime || isImgExt;
        });

        if (files.length === 0) {
            status.innerText = "‚ö†Ô∏è No valid images found in that selection.";
            return;
        }
        
        if (files[0].webkitRelativePath) {
            currentFolderName = files[0].webkitRelativePath.split('/')[0];
        }

        const globalVal = parseInt(sensInput.value);
        let count = 0;

        for (const file of files) {
            if (thisSessionId !== currentSessionId) return;
            
            count++;
            status.innerText = `‚åõ Analyzing ${count} of ${files.length} images...`;

            const img = await loadImage(file);
            const res = autoDetectGutter(img, globalVal);
            
            const item = {
                id: Math.random().toString(36).substr(2, 9),
                img, name: file.name, threshold: globalVal,
                centerX: res.centerX, gutterWidth: res.gutterWidth,
                isOverridden: false, isCenterManuallySet: false
            };
            
            originalImages.push(item);
            renderCard(item);
        }
        
        globalSyncBtn.disabled = downloadBtn.disabled = false;
        status.innerText = `‚úÖ Successfully loaded ${originalImages.length} images from "${currentFolderName}"`;
    });

    globalSyncBtn.onclick = () => {
        const globalVal = parseInt(sensInput.value);
        originalImages.forEach(item => {
            if (!item.isOverridden) {
                item.threshold = globalVal;
                const res = autoDetectGutter(item.img, globalVal);
                item.centerX = res.centerX;
                item.gutterWidth = res.gutterWidth;
                item.refreshUI();
            }
        });
    };

    sensInput.oninput = (e) => sensVal.innerText = e.target.value;

    function renderCard(item) {
        const card = document.createElement('div');
        card.className = 'card';
        card.onmouseenter = () => activeCardId = item.id;
        card.onmouseleave = () => activeCardId = null;
        gallery.appendChild(card);

        item.refreshUI = () => {
            card.innerHTML = `
                <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                    <strong style="font-size:10px; width:70%; overflow:hidden; white-space:nowrap;">${item.name}</strong>
                    <label style="font-size:9px; color:${item.isOverridden ? '#fbbf24' : 'inherit'}">
                        <input type="checkbox" ${item.isOverridden ? 'checked' : ''} id="lock-${item.id}"> LOCK
                    </label>
                </div>
                <div class="preview-container"><canvas id="c-${item.id}" style="cursor:crosshair;"></canvas></div>
                <div style="margin-top:10px; padding:8px; border-radius:4px; background:rgba(0,0,0,0.1); border: 1px solid var(--border);">
                    <label style="font-size:9px;">Sensitivity: <b>${item.threshold}</b></label>
                    <input type="range" style="width:100%" min="5" max="250" value="${item.threshold}" id="s-${item.id}">
                </div>
            `;

            const canvas = card.querySelector(`#c-${item.id}`);
            canvas.width = item.img.width; canvas.height = item.img.height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(item.img, 0, 0);
            
            ctx.fillStyle = "rgba(255, 0, 0, 0.4)";
            ctx.fillRect(item.centerX - (item.gutterWidth/2), 0, item.gutterWidth, item.img.height);
            
            ctx.strokeStyle = item.isOverridden ? "#fbbf24" : "#22d3ee";
            ctx.lineWidth = Math.max(15, item.img.width / 120);
            ctx.beginPath(); ctx.moveTo(item.centerX, 0); ctx.lineTo(item.centerX, item.img.height); ctx.stroke();

            canvas.onclick = (e) => {
                const rect = canvas.getBoundingClientRect();
                item.centerX = (e.offsetX) * (item.img.width / rect.width);
                item.isOverridden = item.isCenterManuallySet = true;
                item.refreshUI();
            };
            
            card.querySelector(`#lock-${item.id}`).onchange = (e) => {
                item.isOverridden = e.target.checked;
                if(!item.isOverridden) item.isCenterManuallySet = false;
                item.refreshUI();
            };
            
            card.querySelector(`#s-${item.id}`).oninput = (e) => {
                item.threshold = parseInt(e.target.value);
                updateLogic(item);
            };
        };
        item.refreshUI();
    }

    function autoDetectGutter(img, threshVal, lockedX = null) {
        let centerX = lockedX !== null ? lockedX : img.width / 2;
        let gutterWidth = 0;
        try {
            let src = cv.imread(img);
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
            let scanW = img.width * 0.2;
            let startX = Math.max(0, Math.min((lockedX || img.width * 0.5) - (scanW/2), img.width - scanW));
            let roi = gray.roi(new cv.Rect(startX, 0, scanW, img.height));
            cv.threshold(roi, roi, threshVal, 255, cv.THRESH_BINARY_INV);
            let colSums = [];
            for (let x = 0; x < roi.cols; x++) {
                let sum = 0;
                for (let y = 0; y < roi.rows; y++) { if (roi.ucharAt(y, x) === 255) sum++; }
                colSums.push(sum / roi.rows);
            }
            let sIdx = -1, eIdx = -1, maxR = 0, curS = -1;
            for(let i=0; i < colSums.length; i++) {
                if(colSums[i] > 0.6) { if(curS === -1) curS = i; }
                else { if(curS !== -1) { if((i-curS) > maxR){ sIdx=curS; eIdx=i; maxR=i-curS; } curS=-1; } }
            }
            if (sIdx !== -1) {
                if (lockedX === null) centerX = startX + ((sIdx + eIdx) / 2);
                gutterWidth = (eIdx - sIdx) + 4;
            }
            src.delete(); gray.delete(); roi.delete();
        } catch (e) { console.warn(e); }
        return { centerX, gutterWidth };
    }

    function loadImage(file) {
        return new Promise(res => {
            const r = new FileReader();
            r.onload = e => { const i = new Image(); i.onload = () => res(i); i.src = e.target.result; };
            r.readAsDataURL(file);
        });
    }

    downloadBtn.onclick = async () => {
        const zip = new JSZip();
        status.innerText = `üì¶ Exporting ${currentFolderName}_SPLIT.zip...`;
        for (const item of originalImages) {
            await addHalfToZip(zip, item.img, 0, item.centerX - (item.gutterWidth/2), `${item.name.split('.')[0]}_A.jpg`);
            await addHalfToZip(zip, item.img, item.centerX + (item.gutterWidth/2), item.img.width - (item.centerX + (item.gutterWidth/2)), `${item.name.split('.')[0]}_B.jpg`);
        }
        const content = await zip.generateAsync({type: "blob"});
        const link = document.createElement('a');
        link.href = URL.createObjectURL(content);
        link.download = `${currentFolderName}_SPLIT.zip`;
        link.click();
        status.innerText = "‚úÖ ZIP Exported!";
    };

    function addHalfToZip(zip, img, x, w, filename) {
        return new Promise(resolve => {
            const c = document.createElement('canvas');
            c.width = w; c.height = img.height;
            c.getContext('2d').drawImage(img, x, 0, w, img.height, 0, 0, w, img.height);
            c.toBlob(b => { zip.file(filename, b); resolve(); }, 'image/jpeg', 0.98);
        });
    }
</script>
</body>
</html>